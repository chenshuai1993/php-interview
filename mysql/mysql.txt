1:myisam innodb的区别：

不同点:
  innodb支持事物                  myisam 不支持事物
  innodb支持行级别锁 也支持表级别锁  myisam 支持表级别锁
  innodb支持外键                  myisam 不支持外键
  innodb不支持全文索引             myisam 支持全文索引   字段(char varchar text blog)
  innodb不支持直接拷贝文件的方法拷贝数据表   myisam支持
  innodb是索引死组织表             myisam 是堆表

2: select * 那个更快
   myisam , 因为myisam内部维护了一个计数器，可以直接获取

3：索引的实现方式
   都是 b+树， innodb 是组织表， myisam 是堆表   索引组织表 和 索引堆表

4：联合索引 要符合最左原则 （a,b,c）  == （a）,(a,b),(a,b,c)
   顺序没关系,以为有查询优化器.
5：mysql的索引的数据结构

6：mysql中的 转让时间的函数()

7：sql优化-
  -explain出来的各种item的意义

  id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
  select_type：查询中每个 select 子句的类型。
  table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
  partitions:匹配的分区信息。
  type:join 类型。
  possible_keys：列出可能会用到的索引。
  key:实际用到的索引。
  key_len:用到的索引键的平均长度，单位为字节。
  ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
  key 指向的对象，比如说驱动表的连接列。
  rows:估计每次需要扫描的行数。
  filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
  extra:重要的补充信息。

  -profile的意义以及使用场景
  Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。

8、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由
  答：拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；
如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗
如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择

9：MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？
  select * from tab where id = 1 for update;
  for update 可以根据条件来完成行锁锁定,  并且id是有索引的才行，
  如果 id 列，没有索引，那么就是全表锁定，并发无从谈起

10：innodb 事物的隔离级别
    事物的4种隔离级别
    读未提交 (read uncommit)
    读已提交 (read commited)
    可重复读 (repeatable read)
    串行    (serializable)

    不同事物隔离级别的现象
    read uncommit: 可以读取其他 session 未提交的脏数据
    read commited: 允许不可重读读取, 但不允许脏读取，提交后，其他会话可以看到提交的数据
    repeatable read: 禁止不可重复读取和脏读取， 以及幻读（innodb独有）
    serializable: 事物只能一个接着一个的执行,但不能并发执行，事物隔离级别最高

    不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差

11：对于有丰富的 SQL 优化的经验
  首先问 mysql 中 sql 优化的思路，如果能准备说出来， ok，那么我就开始问 explain的各种参数了，重点是 select_type， type， possible_key, ref,rows,extra 等参数的各种
值的含义，如果他都回答正确了，那么我再问 file sort 的含义以及什么时候会出现这个分析结果，如果这里他也回答对了，那么我就准备问 profile 分析了，如果这里他也答对了，那么我就会再问一个问 题，
那是曾经 tx 问我的让我郁闷不已的问题，一个 6 亿的表 a，一个 3 亿的表 b，通过外间 tid 关联，你如何最快的查询出满足条件的第 50000 到第 50200中的这 200 条数据记录。
Explain 在上面的题目中有了，这里就不说了。如何最快的查询出满足条件的第 50000 到第 50200 中的这 200 条数据记录？这个我想不出来！
关于 explain 的各种参数，请参考： http://blog.csdn.net/mchdba/article/details/9190771

12：对于有丰富的数据库设计经验
  这个对于数据库设计我真的没有太多的经验，我也就只能问问最基础的， mysql 中varchar(60) 60 是啥含义， int(30)中 30 是啥含义？ 如果他都回答对了，那么我就问 mysql中为什么要这么设计呢？
如果他还回答对了，我就继续问 int(20)存储的数字的上限和下限是多少？这个问题难道了全部的 mysql dba 的应聘者，不得不佩服提出这个问题的金总的睿智啊，因为这个问题回答正确了，
那么他确实认认真真地研究了 mysql 的设计中关于字段类型的细节。至 于丰富的设计数据库的经验，不用着急，这不我上面还有更加厉害的 dba吗，他会搞明白的，那就跟我无关了。
varchar(60)的 60 表示最多可以存储 60 个字符。int(30)的 30 表示客户端显示这个字段的宽度。
为何这么设计？说不清楚，请大家补充 。 int(20)的上限为 2147483647(signed)或者4294967295(unsigned)。


13：关于熟悉 mysql 的锁机制
gap 锁， next-key 锁，以及 innodb 的行锁是怎么实现的，以及 myisam 的锁是怎么实现的等
Innodb 的锁的策略为 next-key 锁，即 record lock+gap lock。是通过在 index 上加 lock 实现的，如果 index 为 unique index，则降级为 record lock,如果是普通 index，则为 next-key lock，如果没有 index，则直接锁住全表。 myisam 直接使用全表扫描。


14：MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
(1)、varchar与char的区别

在单字节字符集下， char（ N） 在内部存储的时候总是定长， 而且没有变长字段长度列表中。 在多字节字符集下面， char(N)如果存储的字节数超过 N，那么 char（ N）将和 varchar（ N）没有区别。在多字节字符集下面，如果存
储的字节数少于 N，那么存储 N 个字节，后面补空格，补到 N 字节长度。 都存储变长的数据和变长字段长度列表。 varchar(N)无论是什么字节字符集，都是变长的，即都存储变长数据和变长字段长度列表。
(2)、varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。
(3)、int（20）中20的涵义

是指显示字符的长度
不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示
(4)、mysql为什么这么设计

对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；
