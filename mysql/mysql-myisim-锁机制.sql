--mysql 🔐 锁机制

--名称解释
    锁是计算机系协调多个进程或者线程并发访问某一个资源的机制，在传统的计算资源中 cpu ram I/0 都是 资源， 数据也是资源，
    mysql 锁机制用来保证数据并发访问的一致性，有效性，和 数据库的并发能力

--mysql锁类型
    表级锁： 开销小，加锁快；不会出现死锁，锁定力度大，发生锁冲突的概率最高，并发最低
    行级锁： 开销大，加锁慢， 会出现死锁，锁定力度小，发生锁冲突的概率最低，并发最高  
    页面锁： 开销和加锁时间介于二者之间， 会出现死锁， 锁定粒度在二至之间

--使用场景
    表级锁：查询为主，只有少量按照索引条件更新数据的应用， 比如 web
    行级锁：更适合有大量按照索引条件并发更新少量不同数据，同时又有并发查询的应用， 比如在线事务处理（OLTP）

--MYISAM 表锁定
    请求锁类型                    
                      读锁              写锁
    当前锁模式  读锁     支持            不支持
              写锁    不支持            不支持
    --总结： mysql对一个表的读锁： 不用阻塞其他用户对该表的读， 会阻塞其他表的写；
              --myisam表的写锁： 阻塞其他用户对该表的读， 阻塞其他表的写；
          --当一个线程获得对一个表的写锁定，只有持有锁的线程可以对表进行更新操作，其他线程的读写都会等待，知道锁被释放为止

    -- myisam 总是一次获得 sql 语句所需要的全部锁，这也正是 myisam 表不会出现死锁 （deadlock）的原因

    -- mysql 支持并发插入。有个选项 concurrent_insert   
    concurrent_insert = 0  不允许并发插入
    concurrent_insert = 1  如果mysql中表中没有空洞（中间没有被删除的行），myisam 允许在一个进程读表的同时，另一个进程从表尾插入记录， 这也是 mysql 的默认设置
    concurrent_insert = 2  mysql myisam表中有没有空洞，都允许并发插入操作

    --锁调度
        --mysql myisam  
        当一个进程请求一个myisam的读锁时， 这时候另一个进程请求myisam的写锁是， mysql怎么处理
        --答案是 写锁会插入到读锁，因为mysql-myisam 表认为写请求比读请求重要，这也是 myisam 表不太适合有大量更新操作和查询操作应用的原因， 因为大量的更新操作会赵成查询操作很难获得读锁， 从而永远阻塞

        --myisam 中有一个设置选项，可以配置 调度行为 low-priority
        low-priority-updates, 可以设置达到不同锁定调度

        --mysql也提过了一个折中的办法来调节读写冲突，给系统参数 max_write_lock_count 设置一个合适的值， 当一个表的读锁定到达这个值后， mysql 就暂时将写请求优先级降低，给读进程一定的锁机会

        --上面已经讨论了写优先调度机制带来的问题和解决问题， 这里还要强调一点， 一些需要长时间运行的查询操作，也会使写进程‘饿死’！ 因此要避免长时间运行的查询操作， 不要总想一条sql-select语句来解决所有问题。 
        --看似巧妙，往往比较复杂，执行时间较长，在可能的情况下，可以通过中间表等措施对 sql 语句做一定的 ’分表‘，让每一个查询都很短时间内完成，减少锁冲突
        --如果复杂查询不可避免，应尽量避免安排在数据库空闲的时间段， --- 比如一些定时统计可以安排在夜间执行      