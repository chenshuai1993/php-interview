--myisam innodb 锁机制
-- innodb 支持事务，支持行级锁


--事务（transaction）及其 ACID 属性:

--名词解释
    --事务是有一组 sql 组成的逻辑处理单元，事务具有以下4个属性， 通常称为数据的 ACID 属性
    原子性(Atomicity) : 事务是一个原子操作单元，其对数据的修改，要么全都执行，那么全都不执行
    一致性(Consistent) : 在事务开始和完成时候，数据都必须保持一致状态，这意味着所有相关的数据规则都必须应用于事务的修改，以保证数据的完整性；事务结束时，所有的内部数据结构（如B树索引或者双向链表）也都必须是正确的
    隔离性(Isolation)  : 数据库系统提过了一定的隔离机制，保证事务在不受外部并发操作影响的 ”独立“ 环境中执行，这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然
    持久性(Durable) : 事务完成之后，他对数据的修改是永久性的， 即使出现系统故障也能够保持

    银行转账就是事物典型一个例子


--并发事务处理带来的问题，
    相对于串行处理来说，并发事务处理能力能大大增加数据库资源的利用率,提高数据库系统的事务吞吐率，从而可以支持更多的用户，但是并发事务处理也会带来一些问题，主要包括以下几个方面
        --更新丢失 （lost update）: 2个人同时编辑同一个文件，后面执行更新的会覆盖前面的更新，导致前面的更新丢失
        --脏读  （Dirty Reads）: 一个事务正在对一条记录做修改， 这个事务完成并提交前， 这条记录的数据就处于不一致的状态了； 这时候，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些 ”脏“ 数据，并据此做进一步处理，就会产生未提交的数据依赖关系， 这种现象被形象的称为 ”脏读“
        --不可重复读 (Non-Repeatable Reads) : 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或者某些记录已经删除了，
        --幻读（Phantom Reads）: 一个事务按照相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足查询条件的新数据，这种现象就称为 ”幻读“

--事务的隔离级别
    ’并发事务‘带来的问题，”更新丢失“ 通常是应该完全避免的
    ”脏读“ ”不可重复读“ ”幻读“ ，其实都是数据库读一致性的问题，必须有数据库提供一定的事务隔离机制来解决，数据库实现事务隔离的方式，基本有2总方式，
        --1 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改
        --2 另一种是不加任何锁， 通过一定的机制生成一个数据请求时间点的一致性数据快照（snapshot）,并用这个快照来提供一定级别（语句级别 或者 事务级别）的一致性读取，  
        --  从用户角度来看，好像是数据库可以提供统一数据，多个版本，因此，这中技术叫做 ”数据多版本并发控制“（MultiVersion Concurrency Control 简称 mvcc 或者 mcc) 也经常称为多版本数据库

--数据库的事务隔离越严格，并发副作用越小， 但付出的代价也就越大，  ”因为事务隔离实质是就是使事务在一定程度上串行化“，这显然与 ”并发“ 是矛盾的，
--同时不同的应用对读一致性和事务隔离的程度也不同    
--为了解决 ”隔离“ 和 ”并发“ 的矛盾， ISO/ANSI SQL92定义了4个事务隔离级别， 
    
    读数据一致性及允许的并发副作用      读数据的一致性      脏读        不可重复读      幻读        
    隔离级别
    未提交读（read uncommited）      最低级别            是          是            是
    已提交读（read commited）        语义级别            否          是            是
    可重复读（Repeatable read）      事务级别            否          否            是
    可序列化（Serializable）         最高级别 事务级别    否          否            否


--获取innodb 行锁争用情况
-- show status like 'innodb_row_lock%'

       